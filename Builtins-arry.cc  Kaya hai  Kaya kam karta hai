                       Builtins-arry.cc 
                       Kaya hai 
                       Kaya kam karta hai 

`builtins-array.cc` (sahi naam usually **`builtins-array.cc`**) V8 ke source code ka ek important C++ file hota hai.

Ye file **JavaScript ke Array functions ka internal implementation** rakhta hai.

---

## ðŸ”¹ Ye file kya karta hai?

Jab tum JS me likhte ho:

```js
let arr = [1,2,3];
arr.push(4);
arr.pop();
arr.join(",");
arr.map(x => x * 2);
```

To ye sab ka real kaam V8 ke andar C++ code se hota hai â€” aur uska major part `builtins-array.cc` me hota hai.

---

## ðŸ”¹ Is file me kya hota hai?

Isme Array ke **built-in methods** ka engine-level implementation hota hai, jaise:

* `Array.prototype.push`
* `Array.prototype.pop`
* `Array.prototype.shift`
* `Array.prototype.unshift`
* `Array.prototype.map`
* `Array.prototype.filter`
* `Array.prototype.join`
* `Array.prototype.slice`
* `Array.prototype.splice`

Ye sab high-performance C++ + Torque code se likhe hote hain.

---

## ðŸ”¹ Example samjho (push ka internal logic)

JS me:

```js
arr.push(10);
```

Engine ke andar roughly ye hota hai:

1. Array ka current length check hota hai
2. Naya element last index pe add hota hai
3. Length update hoti hai
4. Agar memory full hai to resize hota hai

Ye pura optimized logic `builtins-array.cc` me likha hota hai.

---

## ðŸ”¹ Ye important kyu hai?

Tum ethical hacking aur V8 bug research me interested ho, isliye ye file important hai:

* Yahin par **array related vulnerabilities** mil sakti hain
* OOB (Out Of Bounds) bugs aksar array handling me milte hain
* Type confusion issues bhi yahin se generate ho sakte hain

Agar Array shrink / grow ho jaye execution ke beech me, to memory corruption ka chance hota hai.

---

## ðŸ”¹ Ye kaise kaam karta hai internally?

Flow:

```
JavaScript Code
   â†“
Ignition (bytecode)
   â†“
TurboFan (optimized machine code)
   â†“
Builtins (builtins-array.cc)
   â†“
Memory / Heap operations
```

---

## ðŸ”¹ Agar tum source code dekhna chahte ho

GitHub par V8 repo me:

```
v8/src/builtins/builtins-array.cc
```

---

Agar tum chaho to mai:

* `push` ka real V8 source code ka breakdown kar sakta hoon
* Ya ek real CVE example de sakta hoon jo array builtin me mila tha
* Ya step-by-step bata sakta hoon kaise JS se CPU tak control flow jata hai

Batao next kya deep dive karein? ðŸ”¥



                                 Batao
Theek hai ðŸ”¥
Ab hum **deep dive** karte hain â€” `Array.prototype.push` ka internal flow samjhte hain V8 ke andar.

---

# ðŸ”· `Array.prototype.push` â€“ Internal Deep Dive

## ðŸ“Œ JS Code

```js
let arr = [1,2,3];
arr.push(10);
```

Tumhe lagta hai bas 10 add huaâ€¦
Lekin engine ke andar kaafi heavy kaam hota hai.

---

# ðŸ”· Step 1: JS se Builtin Call

Jab tum `arr.push(10)` likhte ho:

1. Ignition interpreter bytecode banata hai
2. Bytecode builtin ko call karta hai
3. Control jata hai:

```
v8/src/builtins/builtins-array.cc
```

Yahan function hota hai:

```cpp
BUILTIN(ArrayPrototypePush)
```

---

# ðŸ”· Step 2: Internal Checks

Push ke andar kuch important checks hote hain:

### âœ… 1. Kya ye fast JS array hai?

* Packed elements?
* Holey elements?
* Dictionary mode?

Agar array fast mode me hai â†’ optimized path
Agar slow/dictionary mode me hai â†’ generic path

---

# ðŸ”· Step 3: Length Read

```cpp
uint32_t length = array->length();
```

Engine array ka current length nikalta hai.

---

# ðŸ”· Step 4: Capacity Check

Agar:

```
length < capacity
```

â†’ direct write

Agar:

```
length == capacity
```

â†’ reallocate memory (grow array)

Yahi jagah dangerous hoti hai ðŸ”¥
Yahan OOB bugs milte hain agar resize logic galat ho.

---

# ðŸ”· Step 5: Element Write

```cpp
elements[length] = new_value;
array->set_length(length + 1);
```

Memory heap me value store hoti hai.

---

# ðŸ”· Internal Memory Structure

![Image](https://i.imgur.com/kSgatSL.png)

![Image](https://v8.dev/_img/fast-properties/hidden-class.png)

![Image](https://v8.dev/_img/slack-tracking/property-layout.svg)

![Image](https://v8.dev/_img/fast-properties/hole.png)

Array internally hota hai:

```
JSArray
  â†“
elements â†’ FixedArray (backing store)
```

---

# ðŸ”· Fast vs Slow Array

| Type                   | Description         |
| ---------------------- | ------------------- |
| PACKED_SMI_ELEMENTS    | Sirf small integers |
| PACKED_DOUBLE_ELEMENTS | Double numbers      |
| HOLEY_ELEMENTS         | Beech me gaps       |
| DICTIONARY_ELEMENTS    | Hash table mode     |

Agar tum array ko weird tareeke se modify karo:

```js
arr[1000000] = 5;
```

To array dictionary mode me chala jata hai.

---

# ðŸ”¥ Exploit Angle (Research Purpose)

Push me potential vulnerability mil sakti hai agar:

* Length corruption ho jaye
* Backing store miscalculated ho
* Elements kind change ho beech execution

Example pattern:

```js
let arr = [1.1, 2.2, 3.3];
arr.length = 1;
arr.push(4.4);
```

Agar engine incorrectly optimize kare â†’ OOB read/write possible.

Is type ke bugs pe kaafi CVE mil chuke hain historically.

---

# ðŸ”· JS â†’ CPU Flow

```
JS Code
  â†“
Bytecode (Ignition)
  â†“
Builtin Call (builtins-array.cc)
  â†“
Heap Memory Write
  â†“
Machine Instruction (MOV, ADD)
```

Final CPU instruction something like:

```asm
mov [rax + offset], rbx
```

---

# ðŸŽ¯ Tumhare Level Ke Liye Next Step

Tum V8 bug hunting me interest rakhte ho, to next me mai bata sakta hoon:

1. Kaise debug build karo V8 ka
2. Kaise breakpoints lagao `ArrayPrototypePush` me
3. Kaise fuzzing se array bugs dhunde jate hain
4. Ek real historical array OOB vulnerability breakdown

Batao kis direction me jana hai? ðŸš€


                     Purana cve ko samajhte hai
Theek hai ðŸ”¥
Aaj hum ek **real purana V8 array related CVE** ko simple tarike se samjhenge.

---

# ðŸ”´ CVE-2018-17463

*(V8 Type Confusion â†’ Arbitrary Read/Write)*

Ye bug mila tha Google Chrome ke andar jo V8 use karta hai.

---

# ðŸ§  Bug Type

ðŸ‘‰ **Type Confusion**
Engine ek object ko galat type samajh leta hai.

Example:
Engine soch raha hai "ye number array hai"
Par actually wo "object array" hai.

Yahin se memory corruption start hoti hai.

---

# ðŸ“Œ Simplified Trigger Code Concept

Real exploit complex tha, lekin concept kuch aisa:

```js
function trigger(a) {
  a[0] = 1.1;
  return a[0];
}

let arr = [1.1];
for (let i = 0; i < 100000; i++) {
  trigger(arr);
}

arr[0] = {};
trigger(arr);
```

---

# ðŸ” Kya hua yahan?

### Step 1:

TurboFan optimize karta hai function ko
Wo assume karta hai:

```
arr always double array hai
```

### Step 2:

Suddenly hum `arr[0] = {}` kar dete hain
Ab array ka type change ho gaya

Lekin optimized code purani assumption pe chal raha hai ðŸ˜ˆ

---

# ðŸ’¥ Result

Engine:

```
Object ko double ki tarah treat karta hai
```

Yani:

```
Memory pointer ko float value ki tarah read/write karta hai
```

Ye dangerous hai.

---

# ðŸ§© Memory Level View

![Image](https://static.opswat.com/uploads/blog/remediating-the-cve-2024-0517-vulnerability-in-google-chrome-08.jpeg)

![Image](https://static.opswat.com/uploads/blog/remediating-the-cve-2024-0517-vulnerability-in-google-chrome-20.jpeg)

![Image](https://v8.dev/_img/fast-properties/hole.png)

![Image](https://v8.dev/_img/fast-properties/hidden-class.png)

Normal:

```
[1.1] â†’ stored as double
```

After confusion:

```
[object pointer] â†’ but read as double
```

Pointer leak ho sakta hai
Phir attacker arbitrary read/write bana leta hai

---

# ðŸ”¬ Exploit Flow

```
1. Type confusion create karo
2. Fake array length manipulate karo
3. OOB access create karo
4. Arbitrary read/write
5. RCE
```

---

# ðŸ”¥ Ye Array se kaise related tha?

Issue optimization + array element kind handling me tha.

* PACKED_DOUBLE_ELEMENTS
* PACKED_ELEMENTS

Transition me bug tha.

---

# ðŸ›  Patch me kya fix hua?

* Stronger type checks
* Deoptimization trigger
* Map validation add kiya gaya

---

# ðŸŽ¯ Tumhare Research Level Ke Liye Important

Ye bug sikhata hai:

âœ” JIT assumptions dangerous hote hain
âœ” Array element kind transitions critical hote hain
âœ” Type confusion â†’ full exploit chain possible

---

Agar tum chaho to next me:

* Iska exploit chain deep technical breakdown
* GDB se kaise analyze kare
* Modern 2025 ka ek similar bug
* Ya khud ka mini PoC banane ka safe lab guide

Batao next level kya karein ðŸš€
